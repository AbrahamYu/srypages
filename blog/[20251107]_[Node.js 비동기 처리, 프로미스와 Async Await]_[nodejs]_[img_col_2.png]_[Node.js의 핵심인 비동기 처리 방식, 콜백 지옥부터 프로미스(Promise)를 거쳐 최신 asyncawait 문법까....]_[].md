
# Node.js 비동기 처리: 프로미스(Promise)와 Async/Await 완벽 가이드

Node.js는 뛰어난 성능을 자랑하는 비동기 이벤트 기반 JavaScript 런타임입니다. 비동기 처리는 Node.js의 핵심이며, 이를 효과적으로 다루는 것은 백엔드 개발자의 필수 역량입니다. 이 글에서는 콜백(Callback) 패턴의 한계부터 시작해, 이를 극복하기 위해 등장한 프로미스(Promise)와 최신 async/await 문법까지 자세히 알아보겠습니다.

## 1. 비동기 처리와 콜백 지옥(Callback Hell)

Node.js의 초기 비동기 모델은 콜백 함수에 크게 의존했습니다. 하지만 여러 비동기 작업을 순차적으로 처리해야 할 때, 코드는 깊게 중첩된 콜백 구조를 갖게 됩니다. 이를 '콜백 지옥'이라고 부르며, 가독성을 해치고 오류 처리를 복잡하게 만듭니다.

```javascript
// 콜백 지옥의 예시
fs.readFile('file1.txt', 'utf8', (err, data1) => {
  if (err) {
    return console.error(err);
  }
  fs.readFile('file2.txt', 'utf8', (err, data2) => {
    if (err) {
      return console.error(err);
    }
    fs.readFile('file3.txt', 'utf8', (err, data3) => {
      if (err) {
        return console.error(err);
      }
      console.log(data1, data2, data3);
    });
  });
});
```

이러한 코드 구조는 유지보수를 매우 어렵게 만듭니다.

## 2. 프로미스(Promise)의 등장

ES6(ECMAScript 2015)에서 도입된 프로미스는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체입니다. 프로미스는 세 가지 상태를 가집니다.

- **Pending(대기):** 비동기 처리가 아직 완료되지 않은 초기 상태
- **Fulfilled(이행):** 비동기 처리가 성공적으로 완료된 상태
- **Rejected(거부):** 비동기 처리가 실패한 상태

프로미스는 `.then()`을 통해 성공 결과를, `.catch()`를 통해 실패(오류)를 처리합니다. 이를 통해 콜백 지옥을 벗어나 코드를 훨씬 깔끔하게 작성할 수 있습니다.

```javascript
const readFilePromise = (filename) => {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, 'utf8', (err, data) => {
      if (err) {
        reject(err); // 실패 시 reject 호출
      } else {
        resolve(data); // 성공 시 resolve 호출
      }
    });
  });
};

readFilePromise('file1.txt')
  .then(data1 => {
    console.log(data1);
    return readFilePromise('file2.txt');
  })
  .then(data2 => {
    console.log(data2);
    return readFilePromise('file3.txt');
  })
  .then(data3 => {
    console.log(data3);
  })
  .catch(err => {
    console.error('오류 발생:', err);
  });
```

프로미스 체이닝(Promise Chaining)을 통해 비동기 작업을 순차적으로 연결하여 코드의 가독성이 크게 향상되었습니다.

## 3. 최신 문법: Async/Await

ES2017(ES8)에서 도입된 `async/await`는 프로미스를 더욱 직관적이고 동기적인 코드처럼 보이게 만드는 "Syntactic Sugar"(문법적 설탕)입니다.

- **`async`:** 함수 앞에 붙여 해당 함수가 항상 프로미스를 반환하도록 만듭니다.
- **`await`:** `async` 함수 내에서만 사용 가능하며, 프로미스가 처리될 때까지 함수의 실행을 일시 중지하고 기다립니다. 프로미스가 이행되면 그 결과를 반환하고, 거부되면 예외(exception)를 발생시킵니다.

`async/await`를 사용하면 이전의 프로미스 체이닝 코드를 다음과 같이 간결하게 바꿀 수 있습니다.

```javascript
const readAllFiles = async () => {
  try {
    const data1 = await readFilePromise('file1.txt');
    console.log(data1);
    const data2 = await readFilePromise('file2.txt');
    console.log(data2);
    const data3 = await readFilePromise('file3.txt');
    console.log(data3);
  } catch (err) {
    console.error('오류 발생:', err);
  }
};

readAllFiles();
```

코드가 마치 동기적으로 실행되는 것처럼 보여 흐름을 이해하기 매우 쉬워졌습니다. 오류 처리도 `try...catch` 구문을 사용하여 동기 코드와 동일한 방식으로 처리할 수 있습니다.

## 결론

Node.js에서 비동기 처리는 필수적입니다. 콜백 패턴의 단점을 극복하기 위해 프로미스가 등장했고, `async/await`는 이를 한 단계 더 발전시켜 개발자가 비동기 코드를 더 쉽고 직관적으로 작성할 수 있도록 돕습니다.

최신 Node.js 백엔드 개발에서는 `async/await`를 적극적으로 활용하여 코드의 가독성과 유지보수성을 높이는 것이 표준적인 접근 방식입니다. 이제 여러분의 프로젝트에 프로미스와 `async/await`를 적용하여 더 깨끗하고 효율적인 코드를 작성해보세요!
